\documentclass{article}

\usepackage[spanish]{babel}
\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

% Useful packages
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{csvsimple}
\usepackage{graphicx}
\usepackage{verbatim}
\usepackage{listings}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\lstdefinestyle{Rstyle}{
    language=R,
    basicstyle=\ttfamily,
    numbers=left,
    numberstyle=\tiny,
    breaklines=true,
    stepnumber=1,
    numbersep=10pt,
    backgroundcolor=\color{white},
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    frame=single,
    tabsize=1,
    captionpos=b,
    breakatwhitespace=false,
    title=\lstname,
}

\title{Ejercicio 2.3}
\author{Missiego}

\begin{document}
\maketitle

\begin{abstract}
Ejercicios 1.3 y 2.3
\end{abstract}

%Ejercicio 1.3
\section{Ejercicio 1.3}
En esta secciÃ³n vamos a ver cÃ³mo hemos resuelto el ejercicio 1.3 en las clases de laboratorio. Es decir, vamos a repasar lo que hemos visto en clase asÃ­ como ampliarlo en cierta manera.

%Caja y Bigotes
\subsection{El algoritmo Caja y Bigotes}
En R existe una funciÃ³n denominada boxplot(). Dicha funciÃ³n es la encargada de realizar la representaciÃ³n grÃ¡fica en forma de Caja y Bigotes de un dataset (de un conjunto de datos). Podemos encontrar mÃ¡s informaciÃ³n acerca de esta funciÃ³n en la \href{https://search.r-project.org/CRAN/refmans/fields/html/bplot.html}{documentaciÃ³n oficial de R}. Dicha representaciÃ³n grÃ¡fica es de la forma:
\begin{center}
  \includegraphics[width=0.6\textwidth]{./ejemploGraficoBoxplot.png}
\end{center}
Dicha grÃ¡fica ha sido generada con el siguiente cÃ³digo/secuencia de comandos en R:
\begin{center}
\begin{lstlisting}[style=Rstyle, caption=CÃ³digo que genera el boxplot de ejemplo]
ejemploBoxPlot = matrix(c(1,2,3,1,2,45,1,1,4,10,2,3,4,5), 2,7)
ejemploBoxPlot = t(ejemploBoxPlot)
boxplot(ejemploBoxPlot, main="ejemploGraficoBoxplot")
png("ejemploGraficoBoxplot.png")
boxplot(ejemploBoxPlot, main="ejemploGraficoBoxplot")
dev.off()
\end{lstlisting}
\end{center}
Pero, nosotros no queremos una grÃ¡fica, queremos detectar los outliers de una forma prÃ¡ctica. Para ello podemos llamar a la funciÃ³n de boxplot() de la siguiente forma para que nos genere las estadÃ­sticas del mÃ©todo caja y bigotes y no la grÃ¡fica que hemos visto anteriormente.
\begin{center}
\begin{lstlisting}[style=Rstyle, caption=Comandos para generar las estadÃ­sticas del algoritmo Caja y Bigotes de la funciÃ³n nativa de R (boxplot())]
ejemploBoxPlot = matrix(c(1,2,3,1,2,45,1,1,4,10,2,3,4,5), 2,7)
ejemploBoxPlot = t(ejemploBoxPlot)
(boxplot(ejemploBoxPlot, range=1.5, plot=FALSE))
\end{lstlisting}
\end{center}
Lo cual nos da el siguiente resultado: 
<<>>=
ejemploBoxPlot = matrix(c(1,2,3,1,2,45,1,1,4,10,2,3,4,5), 2,7)
(boxplot(ejemploBoxPlot, range=1.5, plot=FALSE))
@

En dicho resultado podemos ver los lÃ­mites (inferior y superior) en la secciÃ³n de \$conf y los outliers en la secciÃ³n de \$out. 

El problema de realizar este procedimiento es que estamos utilizando una funciÃ³n de la cual no conocemos su cÃ³digo interno. Es decir, no conocemos cÃ³mo estÃ¡ procesando los datos para obtener los outliers. PodrÃ­amos decir que es una "caja negra", por ello, para el desarrollo del ejercicio, se realizarÃ¡ obteniendo los cuartiles y los lÃ­mites tal y como hemos visto en clase. La secuencia de comandos es la siguiente:
Antes de realizar el primer paso como tal, tenemos que cargar los datos, lo hacemos de la siguiente forma (creando una matriz muestra y convirtiendola en nu data.frame para que sea accesible de la forma dataframe\$columna):
\begin{center}
\begin{lstlisting}[style=Rstyle, caption=Carga de los datos del ejercicio]
muestra = t(matrix(c(3,2,3.5,12,4.7,4.1,5.2,4.9,7.1,6.1,6.2,5.2,14,5.3),2,7,dimnames=list(c("r","d"))))
muestra = data.frame(muestra)
\end{lstlisting}
\end{center}
Con esto ya tenemos los datos cargados en muestra y podemos acceder a las columnas de la siguiente manera:
\begin{center}
\begin{lstlisting}[style=Rstyle, caption=Acceder a los datos]
r = muestra$r
d = muestra$d
\end{lstlisting}
\end{center}
El contenido de las variables es el siguiente: 
\begin{center}
<<>>=
muestra = t(matrix(c(3,2,3.5,12,4.7,4.1,5.2,4.9,7.1,6.1,6.2,5.2,14,5.3),2,7,dimnames=list(c("r","d"))));
muestra = data.frame(muestra);
r = muestra$r; 
d = muestra$d;
print("Contenido muestra");
print(muestra);
print("Contenido muestra$r");
print(r);
print("Contenido muestra$d");
print(d);
@
\end{center}
Con los datos cargados ya podemos definir el valor d (grado de outlier, distancia a la que un suceso se considera un suceso anÃ³malo):
\begin{center}
\begin{lstlisting}[style=Rstyle, caption=Declaramos el grado de outlier]
d = 1.5
\end{lstlisting}
\end{center}
A continuaciÃ³n, calculamos los cuartiles 1 y 3 sobre el vector "r" (tal y como se pide en el enunciado) con la funciÃ³n nativa de R quantile(). Esta funciÃ³n tambiÃ©n es una "caja negra" debido a que no conocemos cÃ³mo obtiene los cuantiles internamente. Por ello, como veremos mÃ¡s adelante, los resultados de dichos cuartiles son distintos a los que obtuvimos en las clases de teorÃ­a. Esto significa que estÃ¡ procesando los datos de entrada de una forma distinta a cÃ³mo lo hacemos nosotros en los ejercicios de clase.
\begin{center}
\begin{lstlisting}[style=Rstyle, caption=ObtenciÃ³n de los cuartiles]
cuar1r <- quantile(muestra$r, 0.25)
cuar3r <- quantile(muestra$r, 0.75)
\end{lstlisting}
\end{center}
Con los cuartiles 1 y 3 calculados ya podemos aplicar la ecuaciÃ³n que se ha visto en teorÃ­a para obtener los lÃ­mites (si un suceso se encuentra fuera de dichos lÃ­mites, se considerarÃ¡ un outlier o un suceso anÃ³malo). En R lo realizamos de la siguiente forma:
\begin{center}
\begin{lstlisting}[style=Rstyle, caption=ObtenciÃ³n de los lÃ­mites con el mÃ©todo Caja y Bigotes]
intervalo = c(cuar1r - d * (cuar3r - cuar1r), cuar3r + d * (cuar3r - cuar1r)) 
\end{lstlisting}
\end{center}
Finalmente, recorremos todo el dataset sobre el que hemos aplicado el algoritmo Caja y Bigotes (muestra\$r) y mostramos como outliers aquellos sucesos que se encuentran fuera de los lÃ­mites obtenidos anteriormente. Esto lo hemos hecho con un bucle for de la siguiente manera:
\begin{center}
\begin{lstlisting}[style=Rstyle, caption=Clasificar los puntos del dataset como outliers]
for(i in 1:length(muestra$r)){
if(muestra$r[i]<intervalo[1] || muestra$r[i]>intervalo[2]){print("El suceso");print(i);print("Es un outlier")}
}
\end{lstlisting}
\end{center}
Con estos pasos hemos visto cÃ³mo obtenemos los outliers mediante el mÃ©todo que hemos visto en clase de Caja y Bigotes. Cabe destacar de nuevo que el uso de "black-boxes" hace que el resultado no sea el que esperamos (el que hemos obtenido con el mÃ©todo de teorÃ­a) ya que no conocemos con precisiÃ³n cÃ³mo estÃ¡ tratando los datos R en dichas funciones de caja negra.
El resultado obtenido de todo este proceso es el siguiente:
\begin{center}
<<>>=
muestra = t(matrix(c(3,2,3.5,12,4.7,4.1,5.2,4.9,7.1,6.1,6.2,5.2,14,5.3),2,7,dimnames=list(c("r","d"))));
muestra = data.frame(muestra);
d = 1.5;
cuar1r <- quantile(muestra$r, 0.25); 
print(cuar1r);
cuar3r <- quantile(muestra$r, 0.75);
print(cuar3r);
intervalo = c(cuar1r - d * (cuar3r - cuar1r), cuar3r + d * (cuar3r - cuar1r)); 
print(intervalo);
for(i in 1:length(muestra$r)){
if(muestra$r[i]<intervalo[1] || muestra$r[i]>intervalo[2]){print("El suceso");print(i);print("Es un outlier")}
}
@
\end{center}

%MÃ©todo estadÃ­stico (DesviaciÃ³n tÃ­pica)
\subsection{MÃ©todo estadÃ­stico (DesviaciÃ³n tÃ­pica)}
En esta secciÃ³n vamos a ver cÃ³mo realizar el mÃ©todo de obtenciÃ³n de outliers llamado "DesviaciÃ³n tÃ­pica" o de DispersiÃ³n. Este mÃ©todo es un procedimiento estadÃ­stico que es relativamente parecido a "Caja y Bigotes". Vamos a ver cÃ³mo se harÃ­a en R mediante una sucesiÃ³n de comandos. 
Antes de nada tenemos que importar los datos (cargar el dataset para que podamos trabajar con Ã©l). Vamos a hacer lo siguiente:
\begin{center}
\begin{lstlisting}[style=Rstyle, caption=Cargamos los datos como un data frame]
muestra = t(matrix(c(3,2,3.5,12,4.7,4.1,5.2,4.9,7.1,6.1,6.2,5.2,14,5.3),2,7,dimnames=list(c("r","d"))))
muestra = data.frame(muestra)
\end{lstlisting}
\end{center}
Cargamos los datos como un data frame para que pueda ser accesible de la siguiente forma (por nombre de columna):
\begin{center}
\begin{lstlisting}[style=Rstyle, caption=Ejemplos de obtenciÃ³n de datos de columna por nombre]
m_r = muestra$r
m_d = muestra$d
\end{lstlisting}
\end{center}
El grado de outlier se define de forma arbitraria. Nosotros lo hemos establecido a 2 debido a que segÃºn el teorema de Tchebychev el interior de los lÃ­mites obtenidos con la media y la desv. tÃ­pica incluirÃ­an el 75\% de los datos.
\begin{center}
\begin{lstlisting}[style=Rstyle, caption=ElecciÃ³n del grado de outlier (d)]
d = 2;
\end{lstlisting}
\end{center}
Con los datos cargados en "muestra" como un dataframe y el grado de outlier determinado, obtenemos la media y la varianza mediante las siguientes instrucciones:
\begin{center}
\begin{lstlisting}[style=Rstyle, caption=ObtenciÃ³n de la media y la desviaciÃ³n tÃ­pica]
media = mean(muestra$d);
desvTipica = sd(muestra$d);
\end{lstlisting}
\end{center}
Como podemos ver, estas dos funciones son "blackboxes" (al igual que pasaba con ciertas funciones en Caja y Bigotes). Por ello deberÃ­amos optar por una de las dos opciones siguientes:
\begin{enumerate}
    \item Hacer uso de una funciÃ³n de un paquete de la cual conozcamos todo sobre cÃ³mo trata los datos internamente para realizar la media y/o la desviaciÃ³n tÃ­pica
    \item Programar nosotros dichas funciones para tener un control absoluto sobre las mismas
\end{enumerate}
Debido a la simplicidad de los algoritmos de obtenciÃ³n de la media y la desv. tÃ­pica, hemos optado por la segunda opciÃ³n. Para calcular la media y la desv. tÃ­pica con un conjunto de comandos en R se realiza de la siguiente manera:
\begin{center}
\begin{lstlisting}[style=Rstyle, caption=ObtenciÃ³n de media y desv. tÃ­pica mediante comandos en R (algoritmo visto en clase)]
sumatorio = 0;
for(i in 1:length(muestra$d)){
sumatorio = sumatorio + muestra$d[i];
}
media = sumatorio/length(muestra$d);

sumatorioD = 0;
for(i in 1:length(muestra$d)){
sumatorioD = sumatorioD + ((muestra$d[i]-media)^2); #Primero tenemos que haber calculado la media
}
desviacion = sqrt(sumatorioD/length(muestra$d));
\end{lstlisting}
\end{center}
Con la media y la desviaciÃ³n calculada como en clase, obtenemos los lÃ­mites de la siguiente forma:
\begin{center}
\begin{lstlisting}[style=Rstyle, caption=ObtenciÃ³n de lÃ­mites mÃ©todo DesviaciÃ³n TÃ­pica]
limites = c(media - d * desviacion, media + d * desviacion)
\end{lstlisting}
\end{center}
Con los lÃ­mites calculados, recorremos el vector de los datos para determinar si cada uno de los datos es un outlier o no de la siguiente manera:
\begin{center}
\begin{lstlisting}[style=Rstyle, caption=DetecciÃ³n de outliers haciendo uso de los lÃ­mites obtenidos]
for(i in 1:length(muestra$d)){
if(muestra$d[i]<limites[1] || muestra$d[i] > limites[2]){
print("El suceso"); print(i); print("Es un outlier");
}
}
\end{lstlisting}
\end{center}
El resultado de realizar todo esto es el siguiente (primero lo vamos a realizar haciendo uso de las funciones nativas de R para calcular la media y la desviaciÃ³n tÃ­pica):
\begin{center}
<<>>=
muestra = t(matrix(c(3,2,3.5,12,4.7,4.1,5.2,4.9,7.1,6.1,6.2,5.2,14,5.3),2,7,dimnames=list(c("r","d")))); 
muestra = data.frame(muestra); 
d = 2;
media = mean(muestra$d);
desvTipica = sd(muestra$d);
limites = c(media - d * desvTipica, media + d * desvTipica);
print(limites);
print(media);
print(desvTipica);
for(i in 1:length(muestra$d)){
if(muestra$d[i]<limites[1] || muestra$d[i] > limites[2]){
print("El suceso"); print(i); print("Es un outlier");
}
}
@
\end{center}
Como podemos ver, el resultado de ciertas variables, haciendo uso de las funciones nativas de R (las cuales son cajas negras para nostros) es distinto del resultado que obtenemos al realizar el procedimiento que hemos realizado en clase:
\begin{center}
<<>>=
muestra = t(matrix(c(3,2,3.5,12,4.7,4.1,5.2,4.9,7.1,6.1,6.2,5.2,14,5.3),2,7,dimnames=list(c("r","d")))); 
muestra = data.frame(muestra); 
d = 2;
sumatorio = 0;
for(i in 1:length(muestra$d)){
sumatorio = sumatorio + muestra$d[i];
}
media = sumatorio/length(muestra$d);
sumatorioD = 0;
for(i in 1:length(muestra$d)){
sumatorioD = sumatorioD + ((muestra$d[i]-media)^2); #Primero tenemos que haber calculado la media
}
desviacion = sqrt(sumatorioD/length(muestra$d));
limites = c(media - d * desviacion, media + d * desviacion);
print(media);
print(desviacion);
print(limites);
for(i in 1:length(muestra$d)){
if(muestra$d[i]<limites[1] || muestra$d[i] > limites[2]){
print("El suceso"); print(i); print("Es un outlier");
}
}
@
\end{center}
Como se puede ver, los lÃ­mites que se han obtenido son distintos. Esto afecta a la detecciÃ³n de los sucesos anÃ³malos debido a que con lÃ­mites distintos puede que en un caso se detecten outliers que en el otro no y viceversa. 
Usar cajas negras, por lo que se puede observar, es un aspecto negativo en nuestra tarea de detectar outliers. Siempre debemos conocer lo que hace cada una de las funciones y cÃ³mo tratan los datos dichas funciones de forma interna (si no lo hacemos, puede llevarnos a cometer errores, en este caso en la detecciÃ³n de sucesos anÃ³malos). 

%-------------------------------------------------------------------------------------
%Ejercicio 2.3
\section{Ejercicio 2.3}

\subsection{Sobre el dataset}
En esta secciÃ³n veremos distintos temas relacionados con el dataset dado, entre los que cabe destacar cÃ³mo se ha guardado dicho fichero (formato) y cÃ³mo se abre en R para aplicar posteriormente las medidas de ordenaciÃ³n y dispersiÃ³n sobre dichos datos (cada una de las medidas sobre la columna correspondiente)

\subsection{Almacenamiento del dataset y cÃ³mo abrirlo en R}
Se ha elegido, para este ejercicio, almacenar los datos en formato .csv por las siguientes razones:
\begin{itemize}
    \item Simplicidad: simple y fÃ¡cil de entender.

    \item Portabilidad: Compatible con una amplia variedad de software y plataformas.

    \item TamaÃ±o de archivo pequeÃ±o.

    \item Independencia del software.

    \item IntegraciÃ³n con lenguajes de programaciÃ³n: en nuestro caso, R proporiciona una funciÃ³n especÃ­fica para importar datos de un .csv

    \item SeparaciÃ³n de datos estructurados: El formato CSV permite la separaciÃ³n de datos estructurados en columnas y filas.

    \item El formato CSV se ha convertido en un estÃ¡ndar ampliamente aceptado para la transferencia y el intercambio de datos.
\end{itemize}

Por estas y otras razones hemos decidido usar CSV. En concreto, el contenido del fichero que se va a utilizar para esta secciÃ³n de la prÃ¡ctica presente es el siguiente:

\begin{center}
    \verbatiminput{datos2_3.csv}
\end{center}

Antes de continuar al siguiente apartado, nos ha parecido conveniente realizar una visualizaciÃ³n grÃ¡fica de los datos para tener una idea de cÃ³mo estÃ¡n distribuidos antes de realizar cualquier mÃ©todo sobre los mismos. Para ello debemos comprender \textbf{cÃ³mo importar el archivo csv en R} para su posterior uso. Lo haremos de la siguiente manera:
\begin{lstlisting}[style=Rstyle, caption=CÃ³mo importar los datos]
datos2_3 <- read.csv("datos2_3.csv")
velocidades <- datos2_3$Velocidad
temperaturas <- datos2_3$Temperatura
\end{lstlisting}
Obtenemos los siguiente:
\begin{center}
<<>>=
datos2_3 <- read.csv("datos2_3.csv");
velocidades <- datos2_3$Velocidad;
temperaturas <- datos2_3$Temperatura;
print(datos2_3);
print(velocidades);
print(temperaturas);
@
\end{center}

\subsubsection{VisualizaciÃ³n de los datos (columna Velocidad)}

\begin{lstlisting}[style=Rstyle, caption=CÃ³mo obtener la grÃ¡fica para velocidades]
plot(velocidades)
\end{lstlisting}

El resultado de dicho plot es el siguiente:
\begin{center}
<<fig=TRUE>>=
plot(velocidades);
@
\end{center}
Con esto ya tenemos una ligera idea de cÃ³mo son los valores del vector "velocidades"

\subsubsection{VisualizaciÃ³n de los datos (columna Temperatura)}
\begin{center}
\begin{lstlisting}[style=Rstyle, caption=CÃ³mo obtener la grÃ¡fica para temperaturas]
plot(temperaturas)
\end{lstlisting}
\end{center}
El resultado de dicho plot es el siguiente:
\begin{center}
<<fig=TRUE>>=
plot(temperaturas);
@
\end{center}
Con esto ya tenemos una ligera idea de cÃ³mo son los valores del vector "temperaturas"

\subsection{Sobre medidas de ordenaciÃ³n y dispersiÃ³n}
En esta secciÃ³n nos centraremos mÃ¡s en la parte teÃ³rica de dichos mÃ©todos de detecciÃ³n de outliers. Nos centraremos en los algoritmos que se han implementado desde un nivel de abstracciÃ³n mÃ¡s elevado que el cÃ³digo en sÃ­ (posteriormente veremos el cÃ³digo de una forma mÃ¡s detenida).
\subsubsection{Medidas de ordenaciÃ³n (Caja y bigotes)}
\label{CajaYBigotes}
Este mÃ©todo de detecciÃ³n de outliers o sucesos anÃ³malos se basa en el uso de la estadÃ­stica (en concreto con el uso de los cuartiles para obtener lÃ­mites. Todo aquel punto que se encuentre fuera de los lÃ­mites (por encima o por debajo) se considerarÃ¡ un suceso anÃ³malo).
Tal y como hemos visto en clase, el algoritmo sigue los siguientes pasos: 
\begin{enumerate}
    \item DeterminaciÃ³n del grado de outlier o distancia a la que un suceso se considera un outlier. La elecciÃ³n de dicha distancia es arbitraria.
    \item Se ordeana los datos y se obtienen los cuartiles tal y como hemos visto en clase (dependiendo si n*c es un nÃºmero con decimales o no)
    \item Se calculan los lÃ­mites del intervalo para los valores atÃ­picos utilizando la siguiente ecuaciÃ³n:
    \begin{center}
    (Q1 - d*(Q3-Q1), Q3 + d*(Q3-Q1))
    \end{center}
    Siendo Q1 y Q3 los cuartiles 1 y 3 respectivamente y "d" la distancia a la que un suceso se considera un outlier
    \item Se identifican los outlier como aquellos valores que quedan fuera del intervalo calculado en el paso 3
\end{enumerate}
Sabiendo esto podemos crear un algoritmo en R para la detecciÃ³n de outliers de una forma relativamente sencilla. Este algoritmo se mostrarÃ¡ y explicarÃ¡ mÃ¡s adelante. 
\subsubsection{Medidas de dispersiÃ³n (DesviaciÃ³n tÃ­pica)}
\label{DesvTipica}
La identificaciÃ³n de sucesos anÃ³malos mediante medidas de dispersiÃ³n como la DesviaciÃ³n TÃ­pica hace uso (al igual que Caja y Bigotes) de mÃ©todos estadÃ­ticos.
Tal y como hemos visto en clase, el algoritmo sigue los siguientes pasos:
\begin{enumerate}
    \item DeterminaciÃ³n del grado de outlier (arbitrario)
    \item ObtenciÃ³n de la media aritmÃ©tica
    \item ObtenciÃ³n de la desviaciÃ³n tÃ­pica
    \item CÃ¡lculo de los lÃ­mites del intervalo haciendo uso de la siguiente ecuaciÃ³n:
    \begin{center}
    (xa - d*sa, xa + d*sa)
    \end{center}
    Siendo "xa" la media aritmÃ©tica, "d" el grado de outlier y "sa" la desviaciÃ³n tÃ­pica.
    \item Se identifican los outlier como aquellos valores que quedan fuera del intervalo calculado en el paso 4
\end{enumerate}
Si establecemos d = 2, por el teorema de Tchebychev, en el intervalo calculado en el paso 4 se encuentran el 75\% de los datos
Sabiendo esto podemos crear un algoritmo en R para la detecciÃ³n de outliers de una forma relativamente sencilla. Este algoritmo se mostrarÃ¡ y explicarÃ¡ mÃ¡s adelante.

\subsection{Algoritmos}
En esta secciÃ³n vamos a ver los algoritmos que se han programado en R para el ejercicio en cuestiÃ³n. Dichos algortimos son 2 en concreto y son los que hemos mencionado anteriormente:
\begin{enumerate}
    \item Caja y Bigotes
    \item DesviaciÃ³n tÃ­pica
\end{enumerate}
\subsubsection{Algoritmo Caja y Bigotes}
El cÃ³digo que se ha desarrollado para este algoritmo sigue los mismos pasos que se han explicado en la secciÃ³n en la que se trata el algoritmo en profundidad (SecciÃ³n \ref{CajaYBigotes}) 
El cÃ³digo en sÃ­ es el siguiente: 
\begin{center}
\begin{lstlisting}[style=Rstyle, caption=Algoritmo Caja y Bigotes para detecciÃ³n de outliers]
caja_bigotes <- function(datos,d){
	#Aplicamos el algoritmo que hemos visto en clase
	cuantil1 = cuantil(datos,0.25);
	cuantil3 = cuantil(datos,0.75);
	limites = c(cuantil1 - d*(cuantil3-cuantil1), cuantil3 + d*(cuantil3-cuantil1))
	#Mostramos los limites:
	print("Limites: ");
	print(limites);
	#Obtenemos los outlier (los mostramos por pantalla)
	for(i in 1:length(datos)){
		if(datos[i] < limites[1] || datos[i] > limites[2]){
			print("El suceso");
			print(i);
			print("Con valor");
			print(datos[i]);
			print("Es un outlier");
		}
	}
}
\end{lstlisting}
\end{center}
Como podemos ver, se sigue la misma estructura que se ha mencionado anteriormente. Para la obtenciÃ³n final de los outlier recorremos todo el vector de entrada y comparamos si estÃ¡ fuera de los lÃ­mites. Si dicho punto se encuentra fuera de los lÃ­mites obtenidos con el mÃ©todo Caja y Bigotes, mostramos el punto, su valor y lo clasificamos como outlier (lÃ­neas 10-18)
Es importante destacar que la ordenaciÃ³n de los datos se realiza en la funciÃ³n "cuantil()". Dicha funciÃ³n tiene el siguiente contenido (mÃ©todo que hemos realizado en clase para obtener los cuantiles):
\begin{center}
\begin{lstlisting}[style=Rstyle, caption=FunciÃ³n de obtenciÃ³n de cuantiles en R]
cuantil <- function(datos,v){
	#Ordenamos los datos
	datos = sort(datos);
	#Realizamos el mismo procedimiento que hemos hecho en clase:
	nc = length(datos)*v;
	if (is.integer(nc)) {
    		x = (datos[nc] + datos[nc+1])/2;
  	} else {
    		x = datos[floor(nc)+1];
	}
	return(x)
}    
\end{lstlisting}
\end{center}
MÃ¡s adelante veremos cÃ³mo se utiliza este algoritmo sobre los datos que se dan en el enunciado asÃ­ como los resultados del mismo.
\subsubsection{Algoritmo DesviaciÃ³n tÃ­pica}
El cÃ³digo que se ha desarrollado para este algoritmo sigue los mismos pasos que se han explicado en la secciÃ³n en la que se trata el algoritmo en profundidad (SecciÃ³n \ref{DesvTipica}) 
El cÃ³digo en sÃ­ es el siguiente: 
\begin{center}
\begin{lstlisting}[style=Rstyle, caption=Algoritmo de detecciÃ³n de outliers mediante DesviaciÃ³n TÃ­pica]
outliers_alg_disp <- function(datos, d)
{
	#Declaramos las variables temporales que se van a utilizar en la funcion
	sumatorio = 0;
	sumatorioD = 0;	
	
	#Calculamos la media:
	for(i in 1:length(datos)){
		sumatorio = sumatorio + datos[i];
	}
	media = sumatorio/length(datos); 

	#Calculamos la desviacion tipica
	for(i in 1:length(datos)){
		sumatorioD = sumatorioD + ((datos[i]-media)^2);
	}
	desviacion = sqrt(sumatorioD/length(datos));
	
	#Calculamos los limites de la siguiente forma:
	limites = c(media - desviacion * d, media + desviacion * d)
	#Mostramos los limites
	print("Limites: ");
	print(limites);
	
	#Obtenemos los outlier (los mostramos por pantalla)
	for(i in 1:length(datos)){
		if(datos[i] < limites[1] || datos[i] > limites[2]){
			print("El suceso");
			print(i);
			print("Con valor");
			print(datos[i]);
			print("Es un outlier");
		}
	}
}
\end{lstlisting}
\end{center}
Vamos a analizar el cÃ³digo detenidamente aunque siga los pasos que se han descrito cuando se ha explicado el algoritmo. Las variables \textit{sumatorio} y \textit{sumatorioD} son variables auxiliares que se utilizan para calcular la media y la desviaciÃ³n tÃ­pica. Hemos hecho uso tanto de la media aritmÃ©tica y de la desviaciÃ³n tÃ­pica estÃ¡ndar (tal y como se puede ver en el cÃ³digo hemos programado el cÃ¡lculo de dichas variables como se ha explicado en teorÃ­a). 
Cuando ya tenemos la media y la desviaciÃ³n tÃ­pica, se calculan los lÃ­mites y recorremos (al igual que se ha hecho en el anterior algoritmo) el vector de los datos comprobando si el punto actual se encuentra dentro de los lÃ­mites o no para clasificarlo como un outlier o como un dato "normal". 
El uso de este algoritmo asÃ­ como los resultados obtenidos sobre el vector "temperaturas" se explicarÃ¡ mÃ¡s adelante.
\subsection{Uso de los algoritmos y resultados obtenidos}
En esta secciÃ³n nos vamos a centrar en el uso de los algoritmos que se han explicado anteriormente asÃ­ como los resultados obtenidos sobre los datos proporcionados en el enunciado. 
\subsubsection{Pasos a seguir para resolver el ejercicio (Caja y Bigotes)}
Antes de comenzar con el desarrollo del ejercicio tenemos que ejecutar las siguientes lÃ­neas para cargar las funciones que se van a utilizar en el mismo:
\begin{center}
\begin{lstlisting}[style=Rstyle,caption=Cargar las funciones]
ruta_caja_bigotes = "./caja_bigotes.R" #Ruta del archivo
ruta_cuantil = "./cuantil.R" #Ruta del archivo
source(ruta_caja_bigotes)
source(ruta_cuantil)
\end{lstlisting}
\end{center}
Para la resoluciÃ³n del ejercicio mediante la tÃ©cnica/algoritmo Caja y Bigotes, primero tenemos que cargar los datos correspondientes. Esto lo hacemos mediante la siguiente combinaciÃ³n de comandos en R en el siguiente orden:
\begin{center}
\begin{lstlisting}[style=Rstyle, caption=Comandos a ejecutar para cargar datos para algoritmo Caja y Bigotes]
rutaDatos2_3 <- "./datos2_3.csv" #Ruta archivo datos
datos2_3 <- read.csv(rutaDatos2_3)
velocidades <- datos2_3$Velocidad
\end{lstlisting}
\end{center}
Ahora que ya tenemos los datos en las variables del workspace, aplicamos el algoritmo que hemos visto anteriormente:
\begin{center}
\begin{lstlisting}[style=Rstyle, caption=Uso del algoritmo caja y bigotes]
d = 0.3 #Grado de outlier, este valor es arbitrario
caja_bigotes(velocidades,d)
\end{lstlisting}
\end{center}

\subsubsection{Pasos a seguir para resolver el ejercicio (Desv. TÃ­pica)}
Antes de resolver el ejercicio con el mÃ©todo de desviaciÃ³n tÃ­pica, tenemos que cargar la funciÃ³n correspondiente.
\begin{center}
\begin{lstlisting}[style=Rstyle, caption=Cargar la funciÃ³n correspondiente]
ruta_dispersion = "./outliers_alg_disp.R" #Ruta del archivo
source(ruta_dispersion)
\end{lstlisting}
\end{center}
Con la funciÃ³n cargada, ya podemos cargar los datos para el ejercicio y aplicar el algoritmo de Desv. TÃ­pica (es lo mismo que dispersiÃ³n. En el cÃ³digo se llama dispersiÃ³n pero es el mismo algoritmo que se ha mencionado anteriormente en el apartado correspondiente). Aplicamos los siguientes comandos para la carga de datos:
\begin{center}
\begin{lstlisting}[style=Rstyle, caption=Cargar los datos en R para algoritmo Desv. TÃ­pica]
ruta_datos2_3 = "./datos2_3.csv"
datos2_3 = read.csv(ruta_datos2_3)
temperaturas = datos2_3$Temperatura
\end{lstlisting}
\end{center}
Con los datos ya cargados aplicamos el algoritmo: 
\begin{center}
\begin{lstlisting}[style=Rstyle, caption=Aplicar el algoritmo de desv. tÃ­pica para detecciÃ³n de outliers]
d = 2 #Escogemos 2 ya que asi se encuentran el 75% de los datos dentro de los limites
outliers_alg_disp(temperaturas,d)
\end{lstlisting}
\end{center}
\subsubsection{Resultados de ejecuciÃ³n}
En esta secciÃ³n podemos encontrar los resultados de ejecutar los cÃ³digos que se han mostrado anteriormente.

Primero, vamos a ver lo que obtenemos con Caja y Bigotes sobre el vector de datos "velocidades":
\begin{center}
<<>>=
source("./cuantil.R");
source("./caja_bigotes.R");
ruta_datos2_3 = "./datos2_3.csv";
datos2_3 = read.csv(ruta_datos2_3);
velocidades = datos2_3$Velocidad;
d = 0.3;
caja_bigotes(velocidades,d);
@
\end{center}

Y con el mÃ©todo de DesviaciÃ³n TÃ­pica sobre el vector de datos "temperaturas":
\begin{center}
<<>>=
source("./dist_manhattan.R");
source("./outliers_alg_disp.R");
ruta_datos2_3 = "./datos2_3.csv";
datos2_3 = read.csv(ruta_datos2_3);
temperaturas = datos2_3$Temperatura;
d = 2;
outliers_alg_disp(temperaturas,d);
@
\end{center}
\end{document}